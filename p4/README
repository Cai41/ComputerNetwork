1. High-level approach:
We have three layers:Ethernet layer, IP layer, TCP layer and raw socket layer. The relationship is as follows:
tcp.recv() -> ip.recv() -> ethernet.recv()
tcp.send() -> ip.send() -> ethernet.send()
utils.py: checksu function
ethernet: build Ethernet frames
ip.py: implementation of IP protocol
tcp.py: implementation of TCP protocol
Arp.py: arp protocol:
rawhttp.py: download files according to url through tcp protocol

2. Featrues implemented on all layers
(1).The ethernet layer add/extract headers from frame, and send/receive frame.
(2).The ip layer use ethernet layer to send/receive packet, add/extract headers from packet. Vertify source ip address
as well as destination address. Also it checks whether checksum is correct for incoming packet and set correct checksum
value for outgoing packet.
(3).The TCP layer use ip layer to send/receive packet, add/extract headers from segment.
For sending side, it implement basic sliding window algorithm: congestion window is used to control the packets on-the-fly,
each time a packet is dropped or timeout, send congestion window to 1, each time an ACK is received increment the window
size which is limited to 1000. For each packet that is not acked within 60 seconds, it is re-transmitted.
For receiving side, we also manage the advertise window in case of the receiver falling behind. We have the maximum buffer of
65535 bytes. If any out-of-order packet is arrived we buffer it until all the packets before it has been received.
(4).The rawsocket send http request by TCP, and receive data from TCP, buffer it while writing to file.

3.Challenges:
(1).ARP
(2).TCP sliding window:
(3).check sum function


4.Test:
(1).tcp.handshake will try connect to server, if failer it would print a message and return
(2).After receving HTTP reponse, if it is 200, then program will return and print an error.
(3).If no data is received within 300 seconds, the program print a warning and return.